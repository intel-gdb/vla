From 6346639c66e5244e588d341f8f96c817cdf03741 Mon Sep 17 00:00:00 2001
From: "H.J. Lu" <hjl.tools@gmail.com>
Date: Mon, 4 Nov 2013 09:26:48 -0800
Subject: [PATCH] Add corrupted symbol table detection

Linker may generate bad output or crash on inputs with corrupted symbol
table.  This patch adds corrupted symbol table detection to ld and
readelf.
---
 ChangeLog.pr12639  | 13 +++++++++++++
 bfd/elfcode.h      | 18 ++++++++++++++++++
 binutils/readelf.c |  9 +++++++--
 3 files changed, 38 insertions(+), 2 deletions(-)
 create mode 100644 ChangeLog.pr12639

diff --git a/ChangeLog.pr12639 b/ChangeLog.pr12639
new file mode 100644
index 0000000..fd0d4a6
--- /dev/null
+++ b/ChangeLog.pr12639
@@ -0,0 +1,13 @@
+bfd/
+
+2011-04-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR binutils/12639
+	* elfcode.h (elf_slurp_symbol_table): Check valid local symbols.
+
+binutils/
+
+2011-04-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR binutils/12639
+	* readelf.c (process_symbol_table): Detect corrupted symtab.
diff --git a/bfd/elfcode.h b/bfd/elfcode.h
index e296c5c..d88ba9e 100644
--- a/bfd/elfcode.h
+++ b/bfd/elfcode.h
@@ -1168,6 +1168,9 @@ elf_slurp_symbol_table (bfd *abfd, asymbol **symptrs, bfd_boolean dynamic)
     sym = symbase = NULL;
   else
     {
+      /* Start of global symbols */
+      Elf_Internal_Sym *start_global;
+
       isymbuf = bfd_elf_get_elf_syms (abfd, hdr, symcount, 0,
 				      NULL, NULL, NULL);
       if (isymbuf == NULL)
@@ -1212,6 +1215,9 @@ elf_slurp_symbol_table (bfd *abfd, asymbol **symptrs, bfd_boolean dynamic)
       if (xver != NULL)
 	++xver;
       isymend = isymbuf + symcount;
+      start_global = isymbuf;
+      if (!elf_bad_symtab (abfd))
+	start_global += hdr->sh_info;
       for (isym = isymbuf + 1, sym = symbase; isym < isymend; isym++, sym++)
 	{
 	  memcpy (&sym->internal_elf_sym, isym, sizeof (Elf_Internal_Sym));
@@ -1270,6 +1276,18 @@ elf_slurp_symbol_table (bfd *abfd, asymbol **symptrs, bfd_boolean dynamic)
 	  if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
 	    sym->symbol.value -= sym->symbol.section->vma;
 
+	  if (isym < start_global
+	      && ELF_ST_BIND (isym->st_info) != STB_LOCAL)
+	    {
+	      (*_bfd_error_handler)
+		(_("%s: corrupted local symbol `%s'"),
+		 abfd->filename, sym->symbol.name);
+
+	      /* Force it to local symbol.  */
+	      isym->st_info = ELF_ST_INFO (STB_LOCAL,
+					   ELF_ST_TYPE (isym->st_info));
+	    }
+
 	  switch (ELF_ST_BIND (isym->st_info))
 	    {
 	    case STB_LOCAL:
diff --git a/binutils/readelf.c b/binutils/readelf.c
index 0389f14..ac863c4 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -9612,7 +9612,7 @@ process_symbol_table (FILE * file)
 	   i < elf_header.e_shnum;
 	   i++, section++)
 	{
-	  unsigned int si;
+	  unsigned int si, start_global;
 	  char * strtab = NULL;
 	  unsigned long int strtab_size = 0;
 	  Elf_Internal_Sym * symtab;
@@ -9645,6 +9645,7 @@ process_symbol_table (FILE * file)
 	  if (symtab == NULL)
 	    continue;
 
+	  start_global = section->sh_info;
 	  if (section->sh_link == elf_header.e_shstrndx)
 	    {
 	      strtab = string_table;
@@ -9669,7 +9670,11 @@ process_symbol_table (FILE * file)
 	      putchar (' ');
 	      print_vma (psym->st_size, DEC_5);
 	      printf (" %-7s", get_symbol_type (ELF_ST_TYPE (psym->st_info)));
-	      printf (" %-6s", get_symbol_binding (ELF_ST_BIND (psym->st_info)));
+	      if (si < start_global
+		  && ELF_ST_BIND (psym->st_info) != STB_LOCAL)
+		printf (" %-6s", "<corrupt>");
+	      else
+		printf (" %-6s", get_symbol_binding (ELF_ST_BIND (psym->st_info)));
 	      printf (" %-7s", get_symbol_visibility (ELF_ST_VISIBILITY (psym->st_other)));
 	      /* Check to see if any other bits in the st_other field are set.
 	         Note - displaying this information disrupts the layout of the
-- 
1.8.3.1

